package capi

import (
	"context"
	"fmt"
	"net/url"
	"os"
	"path/filepath"
	"runtime"

	"github.com/sirupsen/logrus"
	"sigs.k8s.io/controller-runtime/pkg/envtest"
	"sigs.k8s.io/controller-runtime/pkg/manager/signals"

	"github.com/openshift/installer/data"
	"github.com/openshift/installer/pkg/asset"
	"github.com/openshift/installer/pkg/asset/capi/process"
	"github.com/openshift/installer/pkg/asset/capi/process/addr"
	"github.com/openshift/installer/pkg/asset/installconfig"
	providers "github.com/openshift/installer/pkg/cluster-api"
)

var (
	// InstallDir is the directory containing install assets.
	InstallDir string
)

// CAPIControlPlane creates a local capi control plane
// to use as a management cluster.
// TODO: Add support for existing management cluster.
type CAPIControlPlane struct {
	FileList []*asset.File
	LocalCP  LocalControlPlane
}

var _ asset.WritableAsset = (*CAPIControlPlane)(nil)

// Name returns the human-friendly name of the asset.
func (c *CAPIControlPlane) Name() string {
	return "CAPI Control Plane"
}

// Dependencies returns the direct dependency for launching
// the capi control plane.
func (c *CAPIControlPlane) Dependencies() []asset.Asset {
	return []asset.Asset{
		&installconfig.ClusterID{},
		&installconfig.InstallConfig{},
		&LocalControlPlane{},
	}
}

// Generate launches the cluster and generates the terraform state file on disk.
func (c *CAPIControlPlane) Generate(parents asset.Parents) (err error) {
	if InstallDir == "" {
		logrus.Fatalf("InstallDir has not been set for the %q asset", c.Name())
	}

	clusterID := &installconfig.ClusterID{}
	installConfig := &installconfig.InstallConfig{}
	localControlPlane := &LocalControlPlane{}
	parents.Get(clusterID, installConfig, localControlPlane)

	c.LocalCP = *localControlPlane

	// Create a temporary directory to unpack the cluster-api assets
	// and use it as the working directory for the envtest environment.
	manifestDir, err := os.MkdirTemp("", "openshift-cluster-api-manifests")
	if err != nil {
		return err
	}
	if err := data.Unpack(manifestDir, "/cluster-api"); err != nil {
		return err
	}

	controllers := []*controller{
		{
			Name:      "Cluster API",
			Path:      fmt.Sprintf("%s/cluster-api", localControlPlane.BinDir),
			Manifests: []string{manifestDir + "/core-components.yaml"},
		},
		{
			Name:      "AWS Infrastructure Provider",
			Path:      fmt.Sprintf("%s/cluster-api-provider-%s_%s_%s", filepath.Join(localControlPlane.BinDir, providers.AWS.Source), providers.AWS.Name, runtime.GOOS, runtime.GOARCH),
			Manifests: []string{manifestDir + "/aws-infrastructure-components.yaml"},
		},
	}

	// Setup signal handler for stopping the subprocesses.
	ctx := signals.SetupSignalHandler()

	// Run the controllers.
	for _, ct := range controllers {
		if err := c.runController(ctx, ct); err != nil {
			return fmt.Errorf("failed to run controller %q: %w", ct.Name, err)
		}
	}

	go func() {
		// Stop the controllers when the context is cancelled.
		<-ctx.Done()
		for _, ct := range controllers {
			if ct.state != nil {
				ct.state.Stop()
			}
		}
	}()

	return nil
}

type controller struct {
	state *process.State

	Name      string
	Path      string
	Manifests []string
	Args      []string
}

func (c *CAPIControlPlane) runController(ctx context.Context, ct *controller) error {
	wh := envtest.WebhookInstallOptions{
		Paths: ct.Manifests,
	}
	if err := wh.PrepWithoutInstalling(); err != nil {
		return fmt.Errorf("failed to prepare controller %q webhook options: %w", ct.Name, err)
	}
	port, host, err := addr.Suggest("")
	if err != nil {
		return fmt.Errorf("unable to grab random port for serving health checks on: %w", err)
	}

	// TODO(vincepri): Check if these args have already been set, and overwrite.
	ct.Args = append(ct.Args,
		"-v=5",
		"--metrics-bind-addr=:0",
		fmt.Sprintf("--health-addr=%s:%d", host, port),
		fmt.Sprintf("--kubeconfig=%s", c.LocalCP.KubeconfigPath),
		fmt.Sprintf("--webhook-port=%d", wh.LocalServingPort),
		fmt.Sprintf("--webhook-cert-dir=%s", wh.LocalServingCertDir),
	)
	opts := envtest.CRDInstallOptions{
		Scheme:         c.LocalCP.Env.Scheme,
		Paths:          ct.Manifests,
		WebhookOptions: wh,
	}
	if _, err := envtest.InstallCRDs(c.LocalCP.Cfg, opts); err != nil {
		return fmt.Errorf("failed to install controller %q manifests in local control plane: %w", ct.Name, err)
	}
	pr := &process.State{
		Path: ct.Path,
		Args: ct.Args,
		HealthCheck: process.HealthCheck{
			URL: url.URL{
				Scheme: "http",
				Host:   fmt.Sprintf("%s:%d", host, port),
				Path:   "/healthz",
			},
		},
	}
	if err := pr.Init(ct.Name); err != nil {
		return fmt.Errorf("failed to initialize process state for controller %q: %w", ct.Name, err)
	}
	if err := pr.Start(ctx, os.Stdout, os.Stderr); err != nil {
		return fmt.Errorf("failed to start controller %q: %w", ct.Name, err)
	}
	ct.state = pr
	return nil
}

// Files returns the FileList generated by the asset.
func (c *CAPIControlPlane) Files() []*asset.File {
	return c.FileList
}

// Load TODO
func (c *CAPIControlPlane) Load(f asset.FileFetcher) (found bool, err error) {

	return false, nil
}
