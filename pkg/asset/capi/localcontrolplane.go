package capi

import (
	"fmt"
	"os"
	"path/filepath"

	providers "github.com/openshift/installer/pkg/cluster-api"
	"k8s.io/apimachinery/pkg/runtime"
	clientgoscheme "k8s.io/client-go/kubernetes/scheme"
	"k8s.io/client-go/rest"
	"k8s.io/client-go/tools/clientcmd"
	"k8s.io/client-go/tools/clientcmd/api"
	capav1beta1 "sigs.k8s.io/cluster-api-provider-aws/v2/api/v1beta1"
	capav1 "sigs.k8s.io/cluster-api-provider-aws/v2/api/v1beta2"
	clusterv1alpha3 "sigs.k8s.io/cluster-api/api/v1alpha3"
	clusterv1alpha4 "sigs.k8s.io/cluster-api/api/v1alpha4"
	clusterv1 "sigs.k8s.io/cluster-api/api/v1beta1"
	"sigs.k8s.io/controller-runtime/pkg/envtest"

	"github.com/davecgh/go-spew/spew"
	"github.com/openshift/installer/pkg/asset"
	"github.com/openshift/installer/pkg/asset/installconfig"
)

// LocalControlPlane creates a local capi control plane
// to use as a management cluster.
// TODO: Add support for existing management cluster.
type LocalControlPlane struct {
	FileList       []*asset.File
	Env            *envtest.Environment
	BinDir         string
	KubeconfigPath string //TODO: move to its own asset
	Cfg            *rest.Config
}

var _ asset.WritableAsset = (*LocalControlPlane)(nil)

// Name returns the human-friendly name of the asset.
func (c *LocalControlPlane) Name() string {
	return "Local Control Plane"
}

// Dependencies returns the direct dependency for launching
// the local control plane.
func (c *LocalControlPlane) Dependencies() []asset.Asset {
	return []asset.Asset{
		&installconfig.ClusterID{},
		&installconfig.InstallConfig{},
	}
}

// Generate launches the cluster and generates the terraform state file on disk.
func (c *LocalControlPlane) Generate(parents asset.Parents) (err error) {
	clusterID := &installconfig.ClusterID{}
	installConfig := &installconfig.InstallConfig{}
	parents.Get(clusterID, installConfig)

	scheme := runtime.NewScheme()
	_ = clientgoscheme.AddToScheme(scheme)
	_ = clusterv1alpha3.AddToScheme(scheme)
	_ = clusterv1alpha4.AddToScheme(scheme)
	_ = clusterv1.AddToScheme(scheme)
	_ = capav1beta1.AddToScheme(scheme)
	_ = capav1.AddToScheme(scheme)

	c.Env = &envtest.Environment{
		Scheme:                   scheme,
		AttachControlPlaneOutput: false,
	}

	// Create a temporary directory to unpack the cluster-api binaries.
	binDir, err := os.MkdirTemp("", "openshift-cluster-api-bins")
	if err != nil {
		return err
	}
	c.BinDir = binDir
	if err := providers.UnpackClusterAPIBinary(binDir); err != nil {
		return err
	}
	if err := providers.UnpackEnvtestBinaries(binDir); err != nil {
		return err
	}
	if err := providers.AWS.Extract(binDir); err != nil {
		return err
	}

	api := os.Getenv("OPENSHIFT_INSTALL_API")
	if api == "" {
		api = fmt.Sprintf("%s/kube-apiserver", binDir)
	}
	if err := os.Setenv("TEST_ASSET_KUBE_APISERVER", api); err != nil {
		return err
	}
	etcd := os.Getenv("OPENSHIFT_INSTALL_ETCD")
	if etcd == "" {
		etcd = fmt.Sprintf("%s/etcd", binDir)
	}
	if err := os.Setenv("TEST_ASSET_ETCD", etcd); err != nil {
		return err
	}

	c.Cfg, err = c.Env.Start()
	if err != nil {
		spew.Dump("ERROR STARTING")
		return err
	}

	kc := fromEnvTestConfig(c.Cfg)
	{
		wd, err := os.Getwd()
		if err != nil {
			return err
		}
		dir := filepath.Join(wd, "/envtest")
		if err := os.MkdirAll(dir, 0766); err != nil {
			return err
		}
		kf, err := os.Create(filepath.Join(dir, "envtest.kubeconfig"))
		if err != nil {
			return err
		}
		if _, err := kf.Write(kc); err != nil {
			return err
		}
		if err := kf.Close(); err != nil {
			return err
		}
		c.KubeconfigPath = kf.Name()
	}

	spew.Dump("KUBECONFIG =" + c.KubeconfigPath)
	return nil
}

// Files returns the FileList generated by the asset.
func (c *LocalControlPlane) Files() []*asset.File {
	return c.FileList
}

// Load TODO
func (c *LocalControlPlane) Load(f asset.FileFetcher) (found bool, err error) {

	return false, nil
}

func (c *LocalControlPlane) Stop() {
	c.Env.Stop()
}

// fromEnvTestConfig returns a new Kubeconfig in byte form when running in envtest.
func fromEnvTestConfig(cfg *rest.Config) []byte {
	clusterName := "envtest"
	contextName := fmt.Sprintf("%s@%s", cfg.Username, clusterName)
	c := api.Config{
		Clusters: map[string]*api.Cluster{
			clusterName: {
				Server:                   cfg.Host,
				CertificateAuthorityData: cfg.CAData,
			},
		},
		Contexts: map[string]*api.Context{
			contextName: {
				Cluster:  clusterName,
				AuthInfo: cfg.Username,
			},
		},
		AuthInfos: map[string]*api.AuthInfo{
			cfg.Username: {
				ClientKeyData:         cfg.KeyData,
				ClientCertificateData: cfg.CertData,
			},
		},
		CurrentContext: contextName,
	}
	data, _ := clientcmd.Write(c)
	return data
}
