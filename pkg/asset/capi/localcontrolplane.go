package capi

import (
	"fmt"
	"os"

	"k8s.io/client-go/rest"
	"k8s.io/client-go/tools/clientcmd"
	"k8s.io/client-go/tools/clientcmd/api"
	"sigs.k8s.io/controller-runtime/pkg/envtest"

	"github.com/davecgh/go-spew/spew"
	"github.com/openshift/installer/pkg/asset"
	"github.com/openshift/installer/pkg/asset/installconfig"
)

// LocalControlPlane creates a local capi control plane
// to use as a management cluster.
// TODO: Add support for existing management cluster.
type LocalControlPlane struct {
	FileList       []*asset.File
	Env            *envtest.Environment
	KubeconfigPath string //TODO: move to its own asset
	Cfg            *rest.Config
}

var _ asset.WritableAsset = (*LocalControlPlane)(nil)

// Name returns the human-friendly name of the asset.
func (c *LocalControlPlane) Name() string {
	return "Local Control Plane"
}

// Dependencies returns the direct dependency for launching
// the local control plane.
func (c *LocalControlPlane) Dependencies() []asset.Asset {
	return []asset.Asset{
		&installconfig.ClusterID{},
		&installconfig.InstallConfig{},
	}
}

// Generate launches the cluster and generates the terraform state file on disk.
func (c *LocalControlPlane) Generate(parents asset.Parents) (err error) {
	clusterID := &installconfig.ClusterID{}
	installConfig := &installconfig.InstallConfig{}
	parents.Get(clusterID, installConfig)

	c.Env = &envtest.Environment{
		CRDDirectoryPaths: []string{
			"/home/padillon/work/capi/crds",
		},
		AttachControlPlaneOutput: true,
	}

	etcd := os.Getenv("OPENSHIFT_INSTALL_ETCD")
	api := os.Getenv("OPENSHIFT_INSTALL_API")
	kubectl := os.Getenv("OPENSHIFT_INSTALL_KUBECTL")

	if err := os.Setenv("TEST_ASSET_KUBE_APISERVER", api); err != nil {
		return err
	}
	if err := os.Setenv("TEST_ASSET_ETCD", etcd); err != nil {
		return err
	}
	if err := os.Setenv("TEST_ASSET_KUBECTL", kubectl); err != nil {
		return err
	}

	c.Cfg, err = c.Env.Start()
	if err != nil {
		spew.Dump("ERROR STARTING")
		return err
	}

	kc := fromEnvTestConfig(c.Cfg)

	tmpfile, err := os.CreateTemp("", "installer-kubeconfig")
	if err != nil {
		return err
	}

	if _, err := tmpfile.Write(kc); err != nil {
		return err
	}
	if err := tmpfile.Close(); err != nil {
		return err
	}
	c.KubeconfigPath = tmpfile.Name()

	return nil
}

// Files returns the FileList generated by the asset.
func (c *LocalControlPlane) Files() []*asset.File {
	return c.FileList
}

// Load TODO
func (c *LocalControlPlane) Load(f asset.FileFetcher) (found bool, err error) {

	return false, nil
}

func (c *LocalControlPlane) Stop() {
	c.Env.Stop()
}

// fromEnvTestConfig returns a new Kubeconfig in byte form when running in envtest.
func fromEnvTestConfig(cfg *rest.Config) []byte {
	clusterName := "envtest"
	contextName := fmt.Sprintf("%s@%s", cfg.Username, clusterName)
	c := api.Config{
		Clusters: map[string]*api.Cluster{
			clusterName: {
				Server:                   cfg.Host,
				CertificateAuthorityData: cfg.CAData,
			},
		},
		Contexts: map[string]*api.Context{
			contextName: {
				Cluster:  clusterName,
				AuthInfo: cfg.Username,
			},
		},
		AuthInfos: map[string]*api.AuthInfo{
			cfg.Username: {
				ClientKeyData:         cfg.KeyData,
				ClientCertificateData: cfg.CertData,
			},
		},
		CurrentContext: contextName,
	}
	data, _ := clientcmd.Write(c)
	return data
}
