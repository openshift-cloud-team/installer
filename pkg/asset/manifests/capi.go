package manifests

import (
	"fmt"
	"path/filepath"

	"github.com/pkg/errors"
	v1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	capa "sigs.k8s.io/cluster-api-provider-aws/v2/api/v1beta2"
	clusterv1 "sigs.k8s.io/cluster-api/api/v1beta1"
	"sigs.k8s.io/controller-runtime/pkg/client"
	"sigs.k8s.io/yaml"

	"github.com/openshift/installer/pkg/asset"
	"github.com/openshift/installer/pkg/asset/installconfig"
	"github.com/openshift/installer/pkg/asset/openshiftinstall"
	"github.com/openshift/installer/pkg/asset/rhcos"
	awstypes "github.com/openshift/installer/pkg/types/aws"
)

const (
	infraManifestDir    = "infra"
	capiGuestsNamespace = "openshift-cluster-api-guests"
)

var (
	_ asset.WritableAsset = (*ClusterAPI)(nil)
)

// ClusterAPI generates manifests for target cluster
// creation using CAPI.
type ClusterAPI struct {
	FileList  []*asset.File
	Manifests []Manifest
}

type Manifest struct {
	Object   client.Object
	filename string
}

// Name returns a human friendly name for the operator
func (c *ClusterAPI) Name() string {
	return "ClusterAPI Manifests"
}

// Dependencies returns all of the dependencies directly needed by the
// ClusterAPI asset
func (c *ClusterAPI) Dependencies() []asset.Asset {
	return []asset.Asset{
		&installconfig.InstallConfig{},
		&installconfig.ClusterID{},
		&openshiftinstall.Config{},
		&FeatureGate{},
		new(rhcos.Image),
	}
}

// Generate generates the respective operator config.yml files
func (c *ClusterAPI) Generate(dependencies asset.Parents) error {
	installConfig := &installconfig.InstallConfig{}
	clusterID := &installconfig.ClusterID{}
	openshiftInstall := &openshiftinstall.Config{}
	featureGate := &FeatureGate{}
	rhcosImage := new(rhcos.Image)
	dependencies.Get(installConfig, clusterID, openshiftInstall, featureGate, rhcosImage)

	c.FileList = []*asset.File{}
	c.Manifests = []Manifest{}

	platform := installConfig.Config.Platform.Name()

	ns := &v1.Namespace{
		TypeMeta: metav1.TypeMeta{
			Kind: "Namespace",
		},
		ObjectMeta: metav1.ObjectMeta{
			Name: capiGuestsNamespace,
		},
	}
	nsFilename := "00_openshift-cluster-api-guests-ns.yaml"
	c.Manifests = append(c.Manifests, Manifest{ns, nsFilename})

	cluster := &clusterv1.Cluster{
		TypeMeta: metav1.TypeMeta{
			APIVersion: "cluster.x-k8s.io/v1beta1",
			Kind:       "Cluster",
		},
		ObjectMeta: metav1.ObjectMeta{
			Name:      clusterID.InfraID,
			Namespace: capiGuestsNamespace,
		},
		Spec: clusterv1.ClusterSpec{
			InfrastructureRef: &v1.ObjectReference{},
		},
	}

	switch platform {
	case awstypes.Name:
		cluster.Spec.InfrastructureRef.Kind = "AWSCluster"

		id := &capa.AWSClusterControllerIdentity{
			TypeMeta: metav1.TypeMeta{
				APIVersion: "infrastructure.cluster.x-k8s.io/v1beta1",
				Kind:       "AWSClusterControllerIdentity",
			},
			ObjectMeta: metav1.ObjectMeta{
				Name: "default",
			},
			Spec: capa.AWSClusterControllerIdentitySpec{
				AWSClusterIdentitySpec: capa.AWSClusterIdentitySpec{
					AllowedNamespaces: &capa.AllowedNamespaces{
						// TODO: The godoc for this field indicates:
						// An nil or empty list indicates that AWSClusters cannot use the identity from any namespace.
						// Our internal notes say:
						// https://github.com/openshift-cloud-team/cluster-api-installer-poc/blob/main/templates/00_aws-cluster-controller-identity-default.yaml
						// allowedNamespaces: {}  # matches all namespaces
						// Check if this is a discrepency.
					},
				},
			},
		}
		idFn := "00_aws-cluster-controller-identity-default.yaml"
		c.Manifests = append(c.Manifests, Manifest{id, idFn})
	}

	clusterFn := "01-capi-cluster.yaml"
	c.Manifests = append(c.Manifests, Manifest{cluster, clusterFn})

	for _, m := range c.Manifests {
		objData, err := yaml.Marshal(m.Object)
		if err != nil {
			errMsg := fmt.Sprintf("failed to create infrastructure manifest %s from InstallConfig", m.filename)
			return errors.Wrapf(err, errMsg)
		}

		c.FileList = append(c.FileList, &asset.File{
			Filename: filepath.Join(infraManifestDir, m.filename),
			Data:     objData,
		})
	}

	asset.SortFiles(c.FileList)

	return nil
}

// Files returns the files generated by the asset.
func (c *ClusterAPI) Files() []*asset.File {
	return c.FileList
}

// Load returns the openshift asset from disk.
func (c *ClusterAPI) Load(f asset.FileFetcher) (bool, error) {
	yamlFileList, err := f.FetchByPattern(filepath.Join(infraManifestDir, "*.yaml"))
	if err != nil {
		return false, errors.Wrap(err, "failed to load *.yaml files")
	}
	ymlFileList, err := f.FetchByPattern(filepath.Join(infraManifestDir, "*.yml"))
	if err != nil {
		return false, errors.Wrap(err, "failed to load *.yml files")
	}
	jsonFileList, err := f.FetchByPattern(filepath.Join(infraManifestDir, "*.json"))
	if err != nil {
		return false, errors.Wrap(err, "failed to load *.json files")
	}
	fileList := append(yamlFileList, ymlFileList...)
	fileList = append(fileList, jsonFileList...)

	for _, file := range fileList {
		c.FileList = append(c.FileList, file)
	}

	asset.SortFiles(c.FileList)
	return len(c.FileList) > 0, nil
}
