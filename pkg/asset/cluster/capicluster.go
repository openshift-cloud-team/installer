package cluster

import (
	"strings"

	"github.com/pkg/errors"
	"github.com/sirupsen/logrus"

	"github.com/openshift/installer/pkg/asset"
	"github.com/openshift/installer/pkg/asset/capi"
	"github.com/openshift/installer/pkg/asset/installconfig"
	"github.com/openshift/installer/pkg/asset/password"
)

// CAPICluster uses a CAPI Control Plane to generate
// cluster infrastructure.
type CAPICluster struct {
	FileList []*asset.File
}

var _ asset.WritableAsset = (*CAPICluster)(nil)

// Name returns the human-friendly name of the asset.
func (c *CAPICluster) Name() string {
	return "CAPI Cluster"
}

// Dependencies returns the direct dependency for launching
// the capi cluster.
func (c *CAPICluster) Dependencies() []asset.Asset {
	return []asset.Asset{
		&installconfig.ClusterID{},
		&installconfig.InstallConfig{},
		// PlatformCredsCheck, PlatformPermsCheck and PlatformProvisionCheck
		// perform validations & check perms required to provision infrastructure.
		// We do not actually use them in this asset directly, hence
		// they are put in the dependencies but not fetched in Generate.

		// We probably want these but commenting them out for now
		// just to speed up development iterations.
		// &installconfig.PlatformCredsCheck{},
		// &installconfig.PlatformPermsCheck{},
		// &installconfig.PlatformProvisionCheck{},
		// &quota.PlatformQuotaCheck{},
		&password.KubeadminPassword{},
		&capi.CAPIControlPlane{},
	}
}

// Generate launches the cluster.
func (c *CAPICluster) Generate(parents asset.Parents) (err error) {
	if InstallDir == "" {
		logrus.Fatalf("InstallDir has not been set for the %q asset", c.Name())
	}

	clusterID := &installconfig.ClusterID{}
	installConfig := &installconfig.InstallConfig{}
	capiControlPlane := &capi.CAPIControlPlane{}
	parents.Get(clusterID, installConfig, capiControlPlane)

	if fs := installConfig.Config.FeatureSet; strings.HasSuffix(string(fs), "NoUpgrade") {
		logrus.Warnf("FeatureSet %q is enabled. This FeatureSet does not allow upgrades and may affect the supportability of the cluster.", fs)
	}

	if installConfig.Config.Platform.None != nil {
		return errors.New("cluster cannot be created with platform set to 'none'")
	}

	if installConfig.Config.BootstrapInPlace != nil {
		return errors.New("cluster cannot be created with bootstrapInPlace set")
	}

	capiControlPlane.LocalCP.Stop()
	panic("not implemented")

	return nil
}

// Files returns the FileList generated by the asset.
func (c *CAPICluster) Files() []*asset.File {
	return c.FileList
}

// Load returns error if the tfstate file is already on-disk, because we want to
// prevent user from accidentally re-launching the cluster.
func (c *CAPICluster) Load(f asset.FileFetcher) (found bool, err error) {

	return false, nil
}
